# PAT乙级 1045

## 题目描述

著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 *N* 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？

例如给定 $N = 5$, 排列是1、3、2、4、5。则：

- 1 的左边没有元素，右边的元素都比它大，所以它可能是主元；
- 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；
- 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；
- 类似原因，4 和 5 都可能是主元。

因此，有 3 个元素可能是主元。

### 输入格式：

输入在第 1 行中给出一个正整数 *N*（≤105）； 第 2 行是空格分隔的 *N* 个不同的正整数，每个数不超过 109。

### 输出格式：

在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。

### 输入样例：

```in
5
1 3 2 4 5
```

### 输出样例：

```out
3
1 4 5
```

## 分析

这个题目就是说如果一个数左面的值都比它小，右面的值都比它大。那么就可以输出。

## 踩到的坑

- for 不要嵌套。想别的方法去。示例：

  ```c
  for (int l = i - 1; i >= 0; l--) // l 写成了 i
          {
          	if (a[l] > a[i]) flagleft = false; // 不需要 break	
          }
          for (int m = i + 1; i < n; m++)  // m 写成了 i
          {
          	if (a[m] < a[i]) flagright = false;	
          }
          if (flagleft && flagright) b[k++] = a[i];
  }
  
  // 运行超时 不可以嵌套
  ```

- 那么就要换下思路。给a[i]做个递增排序。如果一个元素动了那么肯定不满足要求。所以首先是排序后不动。其次它得大于左边所有数字的最大值。（举个例子就知道为什么这么做了：1 7 5 4 排序后 1 4 5 7，光不动能行吗？）。
- 输出的save数组写成了b数组，垃圾错误；
- 还有，在没有输出时有时换个行，就可以过测试了。这里是测试点3。解题时间2019年5月。这算是PAT题目的一个小规律吧；
- 代码中注释了一些东西给刚刚接触STL的同学简单看看。

## 代码

```c
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int n, k = 0, max = 0, save[100005];
    cin >> n;
    vector<int> a(n), b(n); // 变长数组 vector #include <vector>
    for (int i = 0; i < n; i++){
        cin >> a[i];
        b[i] = a[i];
    }
    sort(a.begin(), a.end()); // 递增排序 头文件 <#include <algorithm>
    for (int i = 0; i < n; i++)
    {
    	if (a[i] == b[i] && b[i] > max) save[k++] = b[i];
    	if (b[i] > max) max = b[i];
    }
    cout << k << endl;
    if (k == 0) cout << endl;
    for (int i = 0; i < k; i++) {
    	if (i == k - 1) {cout << save[i]; break;} // save 写成了 b
    	cout << save[i] << " ";
    }
    return 0;
}
```

#### 参考地址：https://www.liuchuo.net/archives/505

