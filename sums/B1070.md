#PATB 1070 绳结

##题目描述

给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。

![rope.jpg](https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg)

给定 *N* 段绳子的长度，你需要找出它们能串成的绳子的最大长度。

### 输入格式：

每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 *N* (2≤*N*≤104)；第 2 行给出 *N* 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过104。

### 输出格式：

在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。

### 输入样例：

```in
8
10 15 12 3 4 13 1 15
```

### 输出样例：

```out
14
```

##分析

- 这个题目啊，说实话开始有点读不懂，我就翻译它一下：有n段绳子，把它们拼接起来，要最长。拼接的方式不是直接拼接，是拿已拼接的长度 + 新绳子段的长度 的和减半。这样就能看懂了吧。所以这道题的难度在于—**读题**；
- 解决方式有点像这学期学过那个贪心算法，长的要减的次数少一些，这样可以最大；
- 向下取整数，就不进位了，

##代码

```c
#include <iostream>
#include <algorithm>
#include <vector>
int main(){
    int n, res = 0;
    std::cin >> n;
    std::vector<int> len(n);
    for (int i = 0; i < n; i++) std::cin >> len[i];
    sort(len.begin(), len.end());
    res = len[0];
    for (int i = 0; i < n; i++) res = (len[i] + res) / 2;
    std::cout << res;
    return 0;
}
```

##错误

- 我开始直接用了定长数组int len[m]，提交编译错了，看那个意思是没有这个方法，具体报错：request for member ‘begin’ in ‘len’, which is of non-class type ‘int [n]’  sort(len.begin(), len.end())；
- 还有，第一次是不会把绳长折半的，第二个 for 循环下标从 1 开始。