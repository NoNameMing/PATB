## 问题描述

编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。

现给定所有队员的比赛成绩，请你编写程序找出冠军队。

### 输入格式：

输入第一行给出一个正整数 *N*（≤104），即所有参赛队员总数。随后 *N* 行，每行给出一位队员的成绩，格式为：`队伍编号-队员编号 成绩`，其中`队伍编号`为 1 到 1000 的正整数，`队员编号`为 1 到 10 的正整数，`成绩`为 0 到 100 的整数。

### 输出格式：

在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。

### 输入样例：

```in
6
3-10 99
11-5 87
102-1 0
102-3 100
11-9 89
3-2 61
```

### 输出样例：

```out
11 176
```

## 思路

- 用 scanf 处理输入格式的问题

- 每个队伍的选手序号是没用的。队伍号有用，用数组保存。再用队伍数组做下标保存各自队伍的分数。

- 最后比较大小

##代码

```c
#include <iostream>
int main(){
    int n, tno[1001], cnt[1001] = {0}, c, temp = 0, j = 1;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++){
    	 scanf("%d-%d %d", &tno[i], &c, &temp);
    	 cnt[tno[i]] += temp;
    }
    for (int i = 1; i <= 1001; i++)
    {
    	 if (cnt[tno[i]] > cnt[tno[j]]) j = i;
    }
    std::cout << tno[j] << " " << cnt[tno[j]];
    return 0;
}
```

- 问题：测试点2过不去，段错误。估计是边界问题。仍在解决。

## 弃用数组后的代码

```c
#include <iostream>
int main(){
    int n, tno, c, temp, j = 0, cnt[1001] = {0};
    scanf("%d", &n);
    for (int i = 0; i < n; i++){
    	 scanf("%d-%d %d", &tno, &c, &temp);
    	 cnt[tno] += temp; 
    }
    for (int i = 1; i < 1001; i++)
    {
    	 if (cnt[i] > cnt[j]) j = i;
    }
    std::cout << j << " " << cnt[j];
    return 0;
}
```

- AC 但是我不懂原理。
- 这样确实很简单。只用了一个数组，比之前更简洁。但我想知道为什么之前会错。